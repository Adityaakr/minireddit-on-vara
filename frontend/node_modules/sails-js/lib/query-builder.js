import { decodeAddress } from '@gear-js/api';
import { u8aConcat, u8aToHex, isHex } from '@polkadot/util';
import { getPayloadMethod } from './util/lib/payload-method.js';
import { stringToU8aWithPrefix, throwOnErrorReply } from './utils.js';
import { ZERO_ADDRESS } from './consts.js';

class QueryBuilder {
    _api;
    _registry;
    _programId;
    _responseType;
    _prefixByteLength;
    _payload;
    _value = 0n;
    _gasLimit;
    _originAddress;
    _atBlock;
    constructor(_api, _registry, _programId, service, method, payload, payloadType, _responseType) {
        this._api = _api;
        this._registry = _registry;
        this._programId = _programId;
        this._responseType = _responseType;
        const encodedService = stringToU8aWithPrefix(service);
        const encodedMethod = stringToU8aWithPrefix(method);
        const data = payloadType === null ? new Uint8Array() : this._registry.createType(payloadType, payload).toU8a();
        this._payload = u8aConcat(encodedService, encodedMethod, data);
        this._prefixByteLength = encodedMethod.length + encodedService.length;
    }
    /**
     * Get the payload of the query as a hexadecimal string.
     */
    get payload() {
        return u8aToHex(this._payload);
    }
    /**
     * Set the value of the query (default: 0).
     */
    withValue(value) {
        this._value = value;
        return this;
    }
    /**
     * Set the origin address of the query (default: Zero Address).
     * @param address
     */
    withAddress(address) {
        if (isHex(address)) {
            this._originAddress = address;
        }
        else {
            try {
                this._originAddress = decodeAddress(address);
            }
            catch {
                throw new Error('Invalid address.');
            }
        }
        return this;
    }
    /**
     * Set the gas limit of the query (default: max).
     * @param value
     */
    withGasLimit(value) {
        this._gasLimit = value;
        return this;
    }
    /**
     * Set the block hash to query at (default: latest block).
     * @param hash
     */
    atBlock(hash) {
        this._atBlock = hash;
        return this;
    }
    /**
     * Execute the query and return the result.
     */
    async call() {
        const result = await this._api.message.calculateReply({
            destination: this._programId,
            origin: this._originAddress || ZERO_ADDRESS,
            payload: this._payload,
            value: this._value,
            gasLimit: this._gasLimit || this._api.blockGasLimit.toBigInt(),
            at: this._atBlock,
        });
        throwOnErrorReply(result.code, result.payload.toU8a(), this._api.specVersion, this._registry);
        const repsponseWOPrefix = result.payload.slice(this._prefixByteLength);
        const responseDecoded = this._registry.createType(this._responseType, repsponseWOPrefix);
        return responseDecoded[getPayloadMethod(this._responseType)]();
    }
}

export { QueryBuilder };
