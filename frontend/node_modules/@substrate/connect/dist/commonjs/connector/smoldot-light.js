"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScClient = void 0;
const getSpec_js_1 = require("./getSpec.js");
const types_js_1 = require("./types.js");
const isBrowser = ![typeof window, typeof document].includes("undefined");
let _QueueFullError = class {
};
let startPromise = null;
const getStart = () => {
    if (startPromise)
        return startPromise;
    startPromise = import("smoldot").then((sm) => {
        _QueueFullError = sm.QueueFullError;
        return sm.start;
    });
    return startPromise;
};
let startWithByteCodePromise = null;
const getStartWithByteCode = () => {
    if (startWithByteCodePromise)
        return startWithByteCodePromise;
    // @ts-ignore TODO: fix types in smoldot/no-auto-bytecode
    startWithByteCodePromise = import("smoldot/no-auto-bytecode").then((sm) => sm.startWithBytecode);
    return startWithByteCodePromise;
};
const clientReferences = []; // Note that this can't be a set, as the same config is added/removed multiple times
let clientPromise = null;
let clientReferencesMaxLogLevel = 3;
const getClientAndIncRef = (config) => {
    if (config.maxLogLevel && config.maxLogLevel > clientReferencesMaxLogLevel)
        clientReferencesMaxLogLevel = config.maxLogLevel;
    if (clientPromise) {
        clientReferences.push(config);
        if (clientPromise instanceof Promise)
            return clientPromise;
        else
            return Promise.resolve(clientPromise);
    }
    let worker = undefined;
    let portToWorker = undefined;
    if (config.workerFactory) {
        worker = config.workerFactory();
        const { port1, port2 } = new MessageChannel();
        worker.postMessage(port1, [port1]);
        portToWorker = port2;
    }
    const clientOptions = {
        portToWorker,
        forbidTcp: true, // In order to avoid confusing inconsistencies between browsers and NodeJS, TCP connections are always disabled.
        forbidNonLocalWs: true, // Prevents browsers from emitting warnings if smoldot tried to establish non-secure WebSocket connections
        maxLogLevel: 9999999, // The actual level filtering is done in the logCallback
        cpuRateLimit: 0.5, // Politely limit the CPU usage of the smoldot background worker.
        logCallback: (level, target, message) => {
            if (level > clientReferencesMaxLogLevel)
                return;
            // The first parameter of the methods of `console` has some printf-like substitution
            // capabilities. We don't really need to use this, but not using it means that the logs
            // might not get printed correctly if they contain `%`.
            if (level <= 1) {
                console.error("[%s] %s", target, message);
            }
            else if (level === 2) {
                console.warn("[%s] %s", target, message);
            }
            else if (level === 3) {
                console.info("[%s] %s", target, message);
            }
            else if (level === 4) {
                console.debug("[%s] %s", target, message);
            }
            else {
                console.trace("[%s] %s", target, message);
            }
        },
    };
    const newClientPromise = worker
        ? getStartWithByteCode().then((start) => {
            return start({
                ...clientOptions,
                bytecode: new Promise((resolve) => {
                    // In NodeJs, onmessage does not exist in Worker from "node:worker_threads"
                    if (isBrowser)
                        worker.onmessage = (event) => resolve(event.data);
                    // @ts-ignore
                    else
                        worker.on("message", (message) => resolve(message));
                }),
            });
        })
        : getStart().then((start) => start(clientOptions));
    clientPromise = newClientPromise;
    newClientPromise.then((client) => {
        // Make sure that the client we have just created is still desired
        if (clientPromise === newClientPromise)
            clientPromise = client;
        else
            client.terminate();
        // Note that if clientPromise != newClientPromise we know for sure that the client that we
        // return isn't going to be used. We would rather not return a terminated client, but this
        // isn't possible for type check reasons.
        return client;
    });
    clientReferences.push(config);
    return clientPromise;
};
// Must be passed the exact same object as was passed to {getClientAndIncRef}
const decRef = (config) => {
    const idx = clientReferences.indexOf(config);
    if (idx === -1)
        throw new Error("Internal error within smoldot");
    clientReferences.splice(idx, 1);
    // Update `clientReferencesMaxLogLevel`
    // Note how it is set back to 3 if there is no reference anymore
    clientReferencesMaxLogLevel = 3;
    for (const cfg of clientReferences.values()) {
        if (cfg.maxLogLevel && cfg.maxLogLevel > clientReferencesMaxLogLevel)
            clientReferencesMaxLogLevel = cfg.maxLogLevel;
    }
    if (clientReferences.length === 0) {
        if (clientPromise && !(clientPromise instanceof Promise))
            clientPromise.terminate();
        clientPromise = null;
    }
};
const transformErrors = (thunk) => {
    try {
        thunk();
    }
    catch (e) {
        const error = e;
        if (error?.name === "JsonRpcDisabledError")
            throw new types_js_1.JsonRpcDisabledError();
        if (error?.name === "CrashError")
            throw new types_js_1.CrashError(error.message);
        if (error?.name === "AlreadyDestroyedError")
            throw new types_js_1.AlreadyDestroyedError();
        if (error instanceof _QueueFullError)
            throw new types_js_1.QueueFullError();
        throw new types_js_1.CrashError(e instanceof Error ? e.message : `Unexpected error ${e}`);
    }
};
/**
 * Returns a {ScClient} that connects to chains by executing a light client directly
 * from JavaScript.
 *
 * This is quite expensive in terms of CPU, but it is the only choice when the substrate-connect
 * extension is not installed.
 */
const createScClient = (config) => {
    const configOrDefault = config || { maxLogLevel: 3 };
    const internalAddChain = async (chainSpec, options) => {
        const client = await getClientAndIncRef(configOrDefault);
        try {
            const internalChain = await client.addChain({
                chainSpec,
                potentialRelayChains: options?.relayChain
                    ? [options.relayChain]
                    : undefined,
                disableJsonRpc: options?.disableJsonRpc,
                databaseContent: options?.databaseContent,
            });
            return {
                sendJsonRpc: (rpc) => {
                    transformErrors(() => internalChain.sendJsonRpc(rpc));
                },
                nextJsonRpcResponse: () => internalChain.nextJsonRpcResponse(),
                jsonRpcResponses: internalChain.jsonRpcResponses,
                remove: () => {
                    try {
                        transformErrors(() => {
                            internalChain.remove();
                        });
                    }
                    finally {
                        decRef(configOrDefault);
                    }
                },
                addChain: (chainSpec, options) => {
                    return internalAddChain(chainSpec, {
                        ...options,
                        relayChain: internalChain,
                    });
                },
            };
        }
        catch (error) {
            decRef(configOrDefault);
            throw error;
        }
    };
    const addChain = (chainSpec, options) => internalAddChain(chainSpec, options);
    const addWellKnownChain = async (supposedChain, options) => {
        // the following line ensures that the http request for the dynamic import
        // of smoldot and the request for the dynamic import of the spec
        // happen in parallel
        getClientAndIncRef(configOrDefault);
        try {
            return await internalAddChain(await (0, getSpec_js_1.getSpec)(supposedChain), options);
        }
        finally {
            decRef(configOrDefault);
        }
    };
    return {
        addChain,
        addWellKnownChain,
    };
};
exports.createScClient = createScClient;
//# sourceMappingURL=smoldot-light.js.map