import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  ReplyCode,
  decodeAddress
} from "./chunk-NUEPJDAT.js";
import {
  TypeRegistry,
  compactAddLength,
  compactFromU8aLim,
  hexToU8a,
  isHex,
  stringToU8a,
  u8aConcat,
  u8aToHex,
  u8aToString
} from "./chunk-GYWHNJY4.js";
import {
  __publicField,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-EYY4QE5Y.js";

// node_modules/sails-js/lib/index.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());

// node_modules/sails-js/lib/prefix.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
function getServiceNamePrefix(payload, withBytesLength = false) {
  const _payload = hexToU8a(payload);
  const [offset, limit] = compactFromU8aLim(_payload);
  const prefix = u8aToString(_payload.subarray(offset, limit + offset));
  return withBytesLength ? { service: prefix, bytesLength: limit + offset } : prefix;
}
function getFnNamePrefix(payload, withBytesLength = false) {
  const _payload = hexToU8a(payload);
  const [sOff, sLim] = compactFromU8aLim(_payload);
  const serviceOffset = sOff + sLim;
  const [offset, limit] = compactFromU8aLim(_payload.subarray(serviceOffset));
  const prefix = u8aToString(_payload.subarray(serviceOffset + offset, serviceOffset + offset + limit));
  return withBytesLength ? { fn: prefix, bytesLength: offset + limit } : prefix;
}
function getCtorNamePrefix(payload, withBytesLength = false) {
  if (withBytesLength) {
    const { service, bytesLength } = getServiceNamePrefix(payload, true);
    return { ctor: service, bytesLength };
  } else {
    return getServiceNamePrefix(payload);
  }
}

// node_modules/sails-js/lib/transaction-builder.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/sails-js/lib/util/lib/payload-method.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var PayloadMethod;
(function(PayloadMethod2) {
  PayloadMethod2["toNumber"] = "toNumber";
  PayloadMethod2["toBigInt"] = "toBigInt";
  PayloadMethod2["toString"] = "toString";
  PayloadMethod2["toHex"] = "toHex";
  PayloadMethod2["toJSON"] = "toJSON";
})(PayloadMethod || (PayloadMethod = {}));
function getPayloadMethod(type) {
  switch (type) {
    case "u8":
    case "u16":
    case "i8":
    case "i16":
    case "u32":
    case "i32": {
      return PayloadMethod.toNumber;
    }
    case "u64":
    case "u128":
    case "i64":
    case "i128":
    case "U256": {
      return PayloadMethod.toBigInt;
    }
    case "String": {
      return PayloadMethod.toString;
    }
    case "H256": {
      return PayloadMethod.toHex;
    }
    default: {
      return PayloadMethod.toJSON;
    }
  }
}

// node_modules/sails-js/lib/consts.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var ZERO_ADDRESS = u8aToHex(new Uint8Array(32));

// node_modules/sails-js/lib/utils.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
function throwOnErrorReply(code, payload, specVersion, registry) {
  if (code.isSuccess)
    return;
  const replyCode = new ReplyCode(code.toU8a(), specVersion);
  if (!replyCode.isError) {
    throw new Error(`Unable to decode reply code. ${code.toU8a()}`);
  }
  const reason = replyCode.errorReason;
  if (reason.isExecution) {
    const error = reason.executionReason.isUserspacePanic ? new Error(registry.createType("String", payload).toString()) : new Error(reason.executionReason.explanation);
    throw error;
  } else if (reason.isUnavailableActor) {
    const error = reason.unavailableActorReason.isProgramExited ? new Error(`Program exited. Program inheritor is ${registry.createType("[u8;32]", payload).toHex()}`) : new Error(reason.unavailableActorReason.explanation);
    throw error;
  } else {
    throw new Error(reason.explanation);
  }
}
function stringToU8aWithPrefix(value) {
  const str = stringToU8a(value);
  return compactAddLength(str);
}

// node_modules/sails-js/lib/transaction-builder.js
var TransactionBuilder = class {
  constructor(_api, _registry, extrinsic, _service, _method, payload, payloadType, _responseType, _programIdOrCodeOrCodeId, _onProgramCreated) {
    __publicField(this, "_api");
    __publicField(this, "_registry");
    __publicField(this, "_service");
    __publicField(this, "_method");
    __publicField(this, "_responseType");
    __publicField(this, "_onProgramCreated");
    __publicField(this, "_account");
    __publicField(this, "_signerOptions");
    __publicField(this, "_tx");
    __publicField(this, "_voucher");
    __publicField(this, "_gasInfo");
    __publicField(this, "programId");
    __publicField(this, "_prefixByteLength");
    __publicField(this, "_gasLimit");
    this._api = _api;
    this._registry = _registry;
    this._service = _service;
    this._method = _method;
    this._responseType = _responseType;
    this._onProgramCreated = _onProgramCreated;
    const encodedService = this._service ? this._registry.createType("String", this._service).toU8a() : new Uint8Array();
    const encodedMethod = this._registry.createType("String", this._method).toU8a();
    const data = payloadType === null ? new Uint8Array() : this._registry.createType(payloadType, payload).toU8a();
    const _payload = u8aConcat(encodedService, encodedMethod, data);
    this._prefixByteLength = encodedMethod.byteLength;
    if (this._service) {
      this._prefixByteLength += encodedService.byteLength;
    }
    switch (extrinsic) {
      case "send_message": {
        this.programId = _programIdOrCodeOrCodeId;
        this._tx = this._api.message.send({
          destination: this.programId,
          gasLimit: 0,
          payload: _payload,
          value: 0
        });
        break;
      }
      case "upload_program": {
        const { programId, extrinsic: extrinsic2 } = this._api.program.upload({
          code: _programIdOrCodeOrCodeId,
          gasLimit: 0,
          initPayload: _payload
        });
        this.programId = programId;
        this._tx = extrinsic2;
        break;
      }
      case "create_program": {
        const { programId, extrinsic: extrinsic2 } = this._api.program.create({
          codeId: _programIdOrCodeOrCodeId,
          gasLimit: 0,
          initPayload: _payload
        });
        this.programId = programId;
        this._tx = extrinsic2;
        break;
      }
    }
  }
  _getGas(gas, increaseGas) {
    if (increaseGas === 0)
      return gas;
    if (increaseGas < 0 || increaseGas > 100)
      throw new Error("Invalid increaseGas value (0-100)");
    return this._registry.createType("u64", gas.add(gas.muln(increaseGas / 100)));
  }
  _getValue(value) {
    return this._registry.createType("u128", value);
  }
  _setTxArg(index, value) {
    const args = this._tx.args.map((arg, i) => i === index ? value : arg);
    switch (this._tx.method.method) {
      case "uploadProgram": {
        this._tx = this._api.tx.gear.uploadProgram(...args);
        break;
      }
      case "createProgram": {
        this._tx = this._api.tx.gear.createProgram(...args);
        break;
      }
      case "sendMessage": {
        this._tx = this._api.tx.gear.sendMessage(...args);
        break;
      }
    }
  }
  /** ## Get submittable extrinsic */
  get extrinsic() {
    return this._tx;
  }
  /** ## Get payload of the transaction */
  get payload() {
    return this._tx.args[0].toHex();
  }
  /**
   * ## Calculate gas for transaction
   * @param allowOtherPanics Allow panics in other contracts to be triggered (default: false)
   * @param increaseGas Increase the gas limit by a percentage from 0 to 100 (default: 0)
   * @returns
   */
  async calculateGas(allowOtherPanics = false, increaseGas = 0) {
    const source = this._account ? decodeAddress(typeof this._account === "string" ? this._account : this._account.address) : ZERO_ADDRESS;
    let gas;
    let gasArgPosition;
    switch (this._tx.method.method) {
      case "uploadProgram": {
        gas = await this._api.program.calculateGas.initUpload(source, this._tx.args[0].toHex(), this._tx.args[2].toHex(), this._tx.args[4], allowOtherPanics);
        break;
      }
      case "createProgram": {
        gas = await this._api.program.calculateGas.initCreate(source, this._tx.args[0].toHex(), this._tx.args[2].toHex(), this._tx.args[4], allowOtherPanics);
        gasArgPosition = 3;
        break;
      }
      case "sendMessage": {
        gas = await this._api.program.calculateGas.handle(source, this._tx.args[0].toHex(), this._tx.args[1].toHex(), this._tx.args[3], allowOtherPanics);
        gasArgPosition = 2;
        break;
      }
      default: {
        throw new Error("Unknown extrinsic");
      }
    }
    this._gasInfo = gas;
    const finalGas = this._getGas(gas.min_limit, increaseGas);
    this._setTxArg(gasArgPosition, finalGas);
    this._gasLimit = finalGas.toBigInt();
    return this;
  }
  /**
   * ## Set account for transaction
   * @param account
   * @param signerOptions
   */
  withAccount(account, signerOptions) {
    this._account = account;
    if (signerOptions) {
      this._signerOptions = signerOptions;
    }
    return this;
  }
  /**
   * ## Set value for transaction
   * @param value
   */
  withValue(value) {
    switch (this._tx.method.method) {
      case "uploadProgram":
      case "createProgram": {
        this._setTxArg(4, this._getValue(value));
        break;
      }
      case "sendMessage": {
        this._setTxArg(3, this._getValue(value));
        break;
      }
      default: {
        throw new Error("Unknown extrinsic");
      }
    }
    return this;
  }
  /**
   * ## Set gas for transaction
   * @param gas - bigint value or 'max'. If 'max', the gas limit will be set to the block gas limit.
   */
  withGas(gas) {
    const _gas = gas === "max" ? this._api.blockGasLimit : this._registry.createType("u64", gas);
    switch (this._tx.method.method) {
      case "uploadProgram":
      case "createProgram": {
        this._setTxArg(3, _gas);
        break;
      }
      case "sendMessage": {
        this._setTxArg(2, _gas);
        break;
      }
      default: {
        throw new Error("Unknown extrinsic");
      }
    }
    this._gasLimit = _gas.toBigInt();
    return this;
  }
  /**
   * ## Use voucher for transaction
   * @param id Voucher id
   */
  withVoucher(id) {
    if (this._tx.method.method !== "sendMessage") {
      throw new Error("Voucher can be used only with sendMessage extrinsics");
    }
    this._voucher = id;
    return this;
  }
  /**
   * ## Get transaction fee
   */
  async transactionFee() {
    if (!this._account) {
      throw new Error("Account is required. Use withAccount() method to set account.");
    }
    const info = await this._tx.paymentInfo(this._account, this._signerOptions);
    return info.partialFee.toBigInt();
  }
  /**
   * ## Decode response payload from sign and send transaction
   * @param payload - Raw bytes from the reply message
   * @returns Decoded payload
   */
  decodePayload(payload) {
    const method = getPayloadMethod(this._responseType);
    const noPrefixPayload = payload.slice(this._prefixByteLength);
    const type = this._registry.createType(this._responseType, noPrefixPayload);
    return type[method]();
  }
  /**
   * ## Check if the reply is an error and throw if it is
   * @param message - UserMessageSent message
   */
  throwOnErrorReply({ payload, details }) {
    throwOnErrorReply(details.unwrap().code, payload, this._api.specVersion, this._registry);
  }
  /**
   * ## Sign and send transaction
   */
  async signAndSend() {
    if (!this._account) {
      throw new Error("Account is required. Use withAccount() method to set account.");
    }
    if (!this._gasLimit) {
      await this.calculateGas();
    }
    if (this._voucher) {
      const callParams = { SendMessage: this._tx };
      this._tx = this._api.voucher.call(this._voucher, callParams);
    }
    let resolveFinalized;
    const isFinalized = new Promise((resolve) => {
      resolveFinalized = resolve;
    });
    const { msgId, blockHash, programId } = await new Promise((resolve, reject) => this._tx.signAndSend(this._account, this._signerOptions, ({ events, status }) => {
      if (status.isInBlock) {
        let msgId2;
        let programId2;
        for (const { event } of events) {
          const { method, section, data } = event;
          if (section == "gear") {
            if (method === "MessageQueued") {
              msgId2 = data.id.toHex();
            } else if (method == "ProgramChanged") {
              programId2 = data.id.toHex();
            }
          } else if (method === "ExtrinsicSuccess") {
            resolve({ msgId: msgId2, blockHash: status.asInBlock.toHex(), programId: programId2 });
          } else if (method === "ExtrinsicFailed") {
            reject(this._api.getExtrinsicFailedError(event));
          }
        }
      } else if (status.isFinalized) {
        resolveFinalized(true);
      }
    }).catch((error) => {
      reject(error.message);
    }));
    if (this._onProgramCreated && programId) {
      await this._onProgramCreated(programId);
    }
    return {
      msgId,
      blockHash,
      txHash: this._tx.hash.toHex(),
      isFinalized,
      response: async (rawResult = false) => {
        const { data } = await this._api.message.getReplyEvent(this.programId, msgId, blockHash);
        const { payload } = data.message;
        this.throwOnErrorReply(data.message);
        return rawResult ? payload.toHex() : this.decodePayload(payload);
      }
    };
  }
  get gasInfo() {
    return this._gasInfo;
  }
};

// node_modules/sails-js/lib/query-builder.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var QueryBuilder = class {
  constructor(_api, _registry, _programId, service, method, payload, payloadType, _responseType) {
    __publicField(this, "_api");
    __publicField(this, "_registry");
    __publicField(this, "_programId");
    __publicField(this, "_responseType");
    __publicField(this, "_prefixByteLength");
    __publicField(this, "_payload");
    __publicField(this, "_value", 0n);
    __publicField(this, "_gasLimit");
    __publicField(this, "_originAddress");
    __publicField(this, "_atBlock");
    this._api = _api;
    this._registry = _registry;
    this._programId = _programId;
    this._responseType = _responseType;
    const encodedService = stringToU8aWithPrefix(service);
    const encodedMethod = stringToU8aWithPrefix(method);
    const data = payloadType === null ? new Uint8Array() : this._registry.createType(payloadType, payload).toU8a();
    this._payload = u8aConcat(encodedService, encodedMethod, data);
    this._prefixByteLength = encodedMethod.length + encodedService.length;
  }
  /**
   * Get the payload of the query as a hexadecimal string.
   */
  get payload() {
    return u8aToHex(this._payload);
  }
  /**
   * Set the value of the query (default: 0).
   */
  withValue(value) {
    this._value = value;
    return this;
  }
  /**
   * Set the origin address of the query (default: Zero Address).
   * @param address
   */
  withAddress(address) {
    if (isHex(address)) {
      this._originAddress = address;
    } else {
      try {
        this._originAddress = decodeAddress(address);
      } catch {
        throw new Error("Invalid address.");
      }
    }
    return this;
  }
  /**
   * Set the gas limit of the query (default: max).
   * @param value
   */
  withGasLimit(value) {
    this._gasLimit = value;
    return this;
  }
  /**
   * Set the block hash to query at (default: latest block).
   * @param hash
   */
  atBlock(hash) {
    this._atBlock = hash;
    return this;
  }
  /**
   * Execute the query and return the result.
   */
  async call() {
    const result = await this._api.message.calculateReply({
      destination: this._programId,
      origin: this._originAddress || ZERO_ADDRESS,
      payload: this._payload,
      value: this._value,
      gasLimit: this._gasLimit || this._api.blockGasLimit.toBigInt(),
      at: this._atBlock
    });
    throwOnErrorReply(result.code, result.payload.toU8a(), this._api.specVersion, this._registry);
    const repsponseWOPrefix = result.payload.slice(this._prefixByteLength);
    const responseDecoded = this._registry.createType(this._responseType, repsponseWOPrefix);
    return responseDecoded[getPayloadMethod(this._responseType)]();
  }
};

// node_modules/sails-js/lib/primitives/non-zero.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var UNonZeroBase = (value, size) => {
  const _value = BigInt(value);
  if (_value <= 0n) {
    throw new Error("Value is not non-zero");
  }
  if (_value >= 2n ** BigInt(size)) {
    throw new Error("Value is too large");
  }
  return size <= 32 ? Number(value) : value;
};
var NonZeroU8 = (value) => UNonZeroBase(value, 8);
var NonZeroU16 = (value) => UNonZeroBase(value, 16);
var NonZeroU32 = (value) => UNonZeroBase(value, 32);
var NonZeroU64 = (value) => UNonZeroBase(value, 64);
var NonZeroU128 = (value) => UNonZeroBase(value, 128);
var NonZeroU256 = (value) => UNonZeroBase(value, 256);

// node_modules/sails-js/lib/primitives/hash.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/sails-js/lib/util/lib/hex.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
function isHex2(value) {
  return /^0x[0-9a-fA-F]+$/.test(value);
}
function toHex(value) {
  return `0x${[...value].map((byte) => byte.toString(16).padStart(2, "0")).join("")}`;
}

// node_modules/sails-js/lib/primitives/hash.js
var FixedSizedHash = (value, size) => {
  if (typeof value === "string") {
    if (!isHex2(value)) {
      throw new Error("Value is not a hex string");
    }
    if (value.length !== size * 2 + 2) {
      throw new Error("Value has incorrect length");
    }
    return value.toLowerCase();
  } else if (value.length !== size) {
    throw new Error("Value has incorrect length");
  }
  return toHex(value);
};
var H160 = (value) => FixedSizedHash(value, 20);
var H256 = (value) => FixedSizedHash(value, 32);
var ActorId = (value) => FixedSizedHash(value, 32);
var CodeId = (value) => FixedSizedHash(value, 32);
var MessageId = (value) => FixedSizedHash(value, 32);

// node_modules/sails-js/lib/sails.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);

// node_modules/sails-js/lib/util/lib/types.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var getScaleCodecDef = (type, asString = false) => {
  if (type.isPrimitive) {
    const primitive = type.asPrimitive;
    if (primitive.isBool)
      return "bool";
    if (primitive.isChar)
      return "char";
    if (primitive.isNull)
      return "Null";
    if (primitive.isStr)
      return "String";
    if (primitive.isI8)
      return "i8";
    if (primitive.isI16)
      return "i16";
    if (primitive.isI32)
      return "i32";
    if (primitive.isI64)
      return "i64";
    if (primitive.isI128)
      return "i128";
    if (primitive.isU8 || primitive.isNonZeroU8)
      return "u8";
    if (primitive.isU16 || primitive.isNonZeroU16)
      return "u16";
    if (primitive.isU32 || primitive.isNonZeroU32)
      return "u32";
    if (primitive.isU64 || primitive.isNonZeroU64)
      return "u64";
    if (primitive.isU128 || primitive.isNonZeroU128)
      return "u128";
    if (primitive.isU256 || primitive.isNonZeroU256)
      return "U256";
    if (primitive.isActorId || primitive.isCodeId || primitive.isMessageId)
      return "[u8;32]";
    if (primitive.isH256)
      return "H256";
    if (primitive.isH160)
      return "H160";
  }
  if (type.isOptional) {
    return `Option<${getScaleCodecDef(type.asOptional.def)}>`;
  }
  if (type.isResult) {
    return `Result<${getScaleCodecDef(type.asResult.ok.def)}, ${getScaleCodecDef(type.asResult.err.def)}>`;
  }
  if (type.isVec) {
    return `Vec<${getScaleCodecDef(type.asVec.def)}>`;
  }
  if (type.isFixedSizeArray) {
    return `[${getScaleCodecDef(type.asFixedSizeArray.def)}; ${type.asFixedSizeArray.len}]`;
  }
  if (type.isMap) {
    return `BTreeMap<${getScaleCodecDef(type.asMap.key.def)}, ${getScaleCodecDef(type.asMap.value.def)}>`;
  }
  if (type.isUserDefined) {
    return type.asUserDefined.name;
  }
  if (type.isStruct) {
    if (type.asStruct.isTuple) {
      return `(${type.asStruct.fields.map(({ def }) => getScaleCodecDef(def)).join(", ")})`;
    }
    const result = {};
    for (const field of type.asStruct.fields) {
      result[field.name] = getScaleCodecDef(field.def);
    }
    return asString ? JSON.stringify(result) : result;
  }
  if (type.isEnum) {
    if (!type.asEnum.isNesting) {
      return { _enum: type.asEnum.variants.map((v) => v.name) };
    }
    const result = {};
    for (const variant of type.asEnum.variants) {
      result[variant.name] = variant.def ? getScaleCodecDef(variant.def) : "Null";
    }
    return { _enum: result };
  }
  throw new Error("Unknown type :: " + JSON.stringify(type));
};

// node_modules/sails-js/lib/sails.js
var Sails = class {
  constructor(parser) {
    __publicField(this, "_parser");
    __publicField(this, "_program");
    __publicField(this, "_scaleTypes");
    __publicField(this, "_registry");
    __publicField(this, "_api");
    __publicField(this, "_programId");
    this._parser = parser;
  }
  /** ### Set api to use for transactions */
  setApi(api) {
    this._api = api;
    return this;
  }
  /** ### Set program id to interact with */
  setProgramId(programId) {
    this._programId = programId;
    return this;
  }
  /** ### Get program id */
  get programId() {
    return this._programId;
  }
  /**
   * ### Parse IDL from string
   * @param idl - IDL string
   */
  parseIdl(idl) {
    if (!this._parser) {
      throw new Error("Parser not set. Use sails-js-parser package to initialize the parser and pass it to the Sails constructor.");
    }
    this._program = this._parser.parse(idl);
    this.generateScaleCodeTypes();
    return this;
  }
  generateScaleCodeTypes() {
    const scaleTypes = {};
    for (const type of this._program.types) {
      scaleTypes[type.name] = getScaleCodecDef(type.def);
    }
    this._registry = new TypeRegistry();
    this._registry.setKnownTypes({ types: scaleTypes });
    this._registry.register(scaleTypes);
    this._scaleTypes = scaleTypes;
  }
  /** #### Scale code types from the parsed IDL */
  get scaleCodecTypes() {
    if (!this._program) {
      throw new Error("IDL not parsed");
    }
    return this._scaleTypes;
  }
  /** #### Registry with registered types from the parsed IDL */
  get registry() {
    if (!this._program) {
      throw new Error("IDL not parsed");
    }
    return this._registry;
  }
  _getParamsForTxBuilder(params) {
    if (params.length === 0)
      return null;
    if (params.length === 1)
      return params[0].type;
    return `(${params.map((p) => p.type).join(", ")})`;
  }
  _getArgsForTxBuilder(args, params) {
    if (params.length === 0)
      return null;
    if (params.length === 1)
      return args[0];
    return args.slice(0, params.length);
  }
  _getFunctions(service) {
    const funcs = {};
    const queries = {};
    for (const func of service.funcs) {
      const params = func.params.map((p) => ({
        name: p.name,
        type: getScaleCodecDef(p.def),
        typeDef: p.def
      }));
      const returnType = getScaleCodecDef(func.def);
      if (func.isQuery) {
        queries[func.name] = (...args) => {
          if (!this._api) {
            throw new Error("API is not set. Use .setApi method to set API instance");
          }
          if (!this._programId) {
            throw new Error("Program ID is not set. Use .setProgramId method to set program ID");
          }
          return new QueryBuilder(this._api, this.registry, this._programId, service.name, func.name, this._getArgsForTxBuilder(args, params), this._getParamsForTxBuilder(params), returnType);
        };
      } else {
        funcs[func.name] = (...args) => {
          if (!this._api) {
            throw new Error("API is not set. Use .setApi method to set API instance");
          }
          if (!this._programId) {
            throw new Error("Program ID is not set. Use .setProgramId method to set program ID");
          }
          return new TransactionBuilder(this._api, this.registry, "send_message", service.name, func.name, this._getArgsForTxBuilder(args, params), this._getParamsForTxBuilder(params), returnType, this._programId);
        };
      }
      Object.assign(func.isQuery ? queries[func.name] : funcs[func.name], {
        args: params,
        returnType,
        returnTypeDef: func.def,
        docs: func.docs,
        encodePayload: (...args) => {
          if (args.length !== args.length) {
            throw new Error(`Expected ${params.length} arguments, but got ${args.length}`);
          }
          const payload = this.registry.createType(`(String, String, ${params.map((p) => p.type).join(", ")})`, [
            service.name,
            func.name,
            ...args
          ]);
          return payload.toHex();
        },
        decodePayload: (bytes) => {
          const payload = this.registry.createType(`(String, String, ${params.map((p) => p.type).join(", ")})`, bytes);
          const result = {};
          for (const [i, param] of params.entries()) {
            result[param.name] = payload[i + 2].toJSON();
          }
          return result;
        },
        decodeResult: (result) => {
          const payload = this.registry.createType(`(String, String, ${returnType})`, result);
          return payload[2].toJSON();
        }
      });
    }
    return { funcs, queries };
  }
  _getEvents(service) {
    const events = {};
    for (const event of service.events) {
      const t = event.def ? getScaleCodecDef(event.def) : "Null";
      const typeStr = event.def ? getScaleCodecDef(event.def, true) : "Null";
      events[event.name] = {
        type: t,
        typeDef: event.def,
        docs: event.docs,
        is: ({ data: { message } }) => {
          if (!message.destination.eq(ZERO_ADDRESS)) {
            return false;
          }
          if (getServiceNamePrefix(message.payload.toHex()) !== service.name) {
            return false;
          }
          if (getFnNamePrefix(message.payload.toHex()) !== event.name) {
            return false;
          }
          return true;
        },
        decode: (payload) => {
          const data = this.registry.createType(`(String, String, ${typeStr})`, payload);
          return data[2].toJSON();
        },
        subscribe: (cb) => {
          if (!this._api) {
            throw new Error("API is not set. Use .setApi method to set API instance");
          }
          if (!this._programId) {
            throw new Error("Program ID is not set. Use .setProgramId method to set program ID");
          }
          return this._api.gearEvents.subscribeToGearEvent("UserMessageSent", ({ data: { message } }) => {
            if (!message.source.eq(this._programId))
              return;
            if (!message.destination.eq(ZERO_ADDRESS))
              return;
            const payload = message.payload.toHex();
            if (getServiceNamePrefix(payload) === service.name && getFnNamePrefix(payload) === event.name) {
              cb(this.registry.createType(`(String, String, ${typeStr})`, message.payload)[2].toJSON());
            }
          });
        }
      };
    }
    return events;
  }
  /** #### Services with functions and events from the parsed IDL */
  get services() {
    if (!this._program) {
      throw new Error("IDL is not parsed");
    }
    const services = {};
    for (const service of this._program.services) {
      const { funcs, queries } = this._getFunctions(service);
      services[service.name] = {
        functions: funcs,
        queries,
        events: this._getEvents(service)
      };
    }
    return services;
  }
  /** #### Constructor functions with arguments from the parsed IDL */
  get ctors() {
    if (!this._program) {
      throw new Error("IDL not parsed");
    }
    const ctor = this._program.ctor;
    if (!ctor) {
      return null;
    }
    const funcs = {};
    for (const func of ctor.funcs) {
      const params = func.params.map((p) => ({ name: p.name, type: getScaleCodecDef(p.def), typeDef: p.def }));
      funcs[func.name] = {
        args: params,
        encodePayload: (...args) => {
          if (args.length !== args.length) {
            throw new Error(`Expected ${params.length} arguments, but got ${args.length}`);
          }
          if (params.length === 0) {
            return u8aToHex(this.registry.createType("String", func.name).toU8a());
          }
          const payload = this.registry.createType(`(String, ${params.map((p) => p.type).join(", ")})`, [
            func.name,
            ...args
          ]);
          return payload.toHex();
        },
        decodePayload: (bytes) => {
          const payload = this.registry.createType(`(String, ${params.map((p) => p.type).join(", ")})`, bytes);
          const result = {};
          for (const [i, param] of params.entries()) {
            result[param.name] = payload[i + 1].toJSON();
          }
          return result;
        },
        fromCode: (code, ...args) => {
          if (!this._api) {
            throw new Error("API is not set. Use .setApi method to set API instance");
          }
          const builder = new TransactionBuilder(this._api, this.registry, "upload_program", void 0, func.name, this._getArgsForTxBuilder(args, params), this._getParamsForTxBuilder(params), "String", code);
          this._programId = builder.programId;
          return builder;
        },
        fromCodeId: (codeId, ...args) => {
          if (!this._api) {
            throw new Error("API is not set. Use .setApi method to set API instance");
          }
          const builder = new TransactionBuilder(this._api, this.registry, "create_program", void 0, func.name, this._getArgsForTxBuilder(args, params), this._getParamsForTxBuilder(params), "String", codeId);
          this._programId = builder.programId;
          return builder;
        },
        docs: func.docs
      };
    }
    return funcs;
  }
  /** #### Parsed IDL */
  get program() {
    if (!this._program) {
      throw new Error("IDL is not parsed");
    }
    return this._program;
  }
  /** #### Get type definition by name */
  getTypeDef(name) {
    return this.program.getTypeByName(name).def;
  }
};

export {
  getServiceNamePrefix,
  getFnNamePrefix,
  getCtorNamePrefix,
  ZERO_ADDRESS,
  throwOnErrorReply,
  TransactionBuilder,
  QueryBuilder,
  NonZeroU8,
  NonZeroU16,
  NonZeroU32,
  NonZeroU64,
  NonZeroU128,
  NonZeroU256,
  H160,
  H256,
  ActorId,
  CodeId,
  MessageId,
  Sails
};
//# sourceMappingURL=chunk-ELE5DVK5.js.map
