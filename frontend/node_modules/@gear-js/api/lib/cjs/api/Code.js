'use strict';

var util = require('@polkadot/util');
var generate = require('../utils/generate.js');
var prefixes = require('../utils/prefixes.js');
var validate = require('../utils/validate.js');
require('@polkadot/api');
require('@polkadot/util-crypto');
require('@polkadot/types');
require('assert');
require('../default/index.js');
require('../metadata/programMetadata.js');
var program_errors = require('../errors/program.errors.js');
var Transaction = require('./Transaction.js');
var consts = require('../consts.js');
var reply = require('../wasm/reply.js');

class GearCode extends Transaction.GearTransaction {
    /**
     * ### Submit code without initialization
     * @param code
     * @returns Code hash
     */
    async upload(code) {
        const codeHash = generate.generateCodeHash(code);
        await validate.validateCodeId(codeHash, this._api);
        const codeBytes = this._api.createType('Bytes', Array.from(code));
        this.extrinsic = this._api.tx.gear.uploadCode(codeBytes);
        return { codeHash, submitted: this.extrinsic, extrinsic: this.extrinsic };
    }
    /**
     * ### Check that codeId exists on chain
     * @param codeId
     */
    async exists(codeId) {
        if (this._api.specVersion >= consts.SPEC_VERSION.V1900) {
            const codeMetadata = await this._api.query.gearProgram.codeMetadataStorage(codeId);
            return codeMetadata.isSome;
        }
        else {
            const codeMetadata = (await this._api.query.gearProgram.metadataStorage(codeId));
            return codeMetadata.isSome;
        }
    }
    _storageV1900(codeId) {
        if (this._api.specVersion >= consts.SPEC_VERSION.V1900) {
            return this._api.query.gearProgram.codeMetadataStorage(codeId);
        }
        else {
            throw new Error('Unsupported version');
        }
    }
    _storageBeforeV1900(codeId) {
        if (this._api.specVersion < consts.SPEC_VERSION.V1900) {
            return this._api.query.gearProgram.codeStorage(codeId);
        }
        else {
            throw new Error('Unsupported version');
        }
    }
    /**
     * ### Get code storage
     * @param codeId
     * @returns ___[CodeMetadata](https://github.com/gear-tech/gear/blob/master/core/src/code/metadata.rs#L52)___ if connected to the node with version >= 1900,
     * otherwise ___[InstrumentedCode](https://github.com/gear-tech/gear/blob/290c4953a2fd54270ec34333d8cd3f7b97591635/core/src/code/instrumented.rs#L67)___
     */
    async storage(codeId) {
        if (this._api.specVersion >= consts.SPEC_VERSION.V1900) {
            return this._storageV1900(codeId);
        }
        else {
            return this._storageBeforeV1900(codeId);
        }
    }
    /**
     * ### Get static pages of code
     * @param codeId
     */
    async staticPages(codeId) {
        const storage = await this.storage(codeId);
        return storage.isSome ? storage.unwrap().staticPages.toNumber() : null;
    }
    /**
     * ### Get all ids of codes uploaded on connected chain
     * @returns array of code ids uploaded on chain
     */
    async all(count) {
        if (this._api.specVersion >= consts.SPEC_VERSION.V1900) {
            const prefix = this._api.query.gearProgram.codeMetadataStorage.keyPrefix();
            const keys = await this._api.rpc.state.getKeysPaged(prefix, count || 1000);
            if (count === undefined) {
                let nextKeysBatch = 1000;
                while (nextKeysBatch === 1000) {
                    const _endKeys = await this._api.rpc.state.getKeysPaged(prefix, nextKeysBatch, keys[keys.length - 1]);
                    keys.push(..._endKeys);
                    nextKeysBatch = _endKeys.length;
                }
            }
            return prefixes.getIdsFromKeys(keys, prefix);
        }
        else {
            const prefix = this._api.query.gearProgram.metadataStorage.keyPrefix();
            const keys = await this._api.rpc.state.getKeysPaged(prefix, count || 1000);
            const codeIds = prefixes.getIdsFromKeys(keys, prefix);
            return codeIds;
        }
    }
    async metaHash(codeId) {
        const code = (await this._api.query.gearProgram.originalCodeStorage(codeId));
        if (code.isNone) {
            throw new program_errors.CodeDoesNotExistError(codeId);
        }
        const metahash = await reply.getGrReply(code.unwrap().toHex(), 'metahash');
        return util.u8aToHex(metahash);
    }
    async metaHashFromWasm(wasm) {
        const metahash = await reply.getGrReply(wasm, 'metahash');
        return util.u8aToHex(metahash);
    }
}

exports.GearCode = GearCode;
