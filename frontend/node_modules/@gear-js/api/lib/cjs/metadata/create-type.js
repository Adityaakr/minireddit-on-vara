'use strict';

var types = require('@polkadot/types');
var json = require('../utils/json.js');
var metadata = require('./metadata.js');
var index = require('../default/index.js');

class CreateType {
    registry;
    metadata;
    constructor(typesOrHexRegistry) {
        if (!typesOrHexRegistry) {
            this.registry = new types.TypeRegistry();
            this.registerDefaultTypes();
        }
        else if (typeof typesOrHexRegistry === 'string') {
            this.metadata = new metadata.GearMetadata(typesOrHexRegistry);
        }
        else {
            this.registry = new types.TypeRegistry();
            this.registerDefaultTypes();
            this.registerCustomTypes(typesOrHexRegistry);
        }
    }
    registerDefaultTypes() {
        this.registry.setKnownTypes({ types: index.gearTypes });
        this.registry.register(index.gearTypes);
    }
    /**
     * ## Register custom types
     * @param types
     * @example
     * ```javascript
     * const createType = new CreateType();
     * createType.registerCustomTypes({
     *   MyType: 'u32',
     *   MyStruct: {
     *     field1: 'u8',
     *     field2: 'u16',
     *   },
     * });
     * ```
     */
    registerCustomTypes(types) {
        this.registry.setKnownTypes({ types });
        this.registry.register(types);
    }
    /**
     * Create a type instance for encoding or decoding payloads
     *
     * @param type The type name or type index to encode/decode the payload. Can be:
     * - A built-in type like 'String', 'u32', etc.
     * - A custom type that was registered via registerCustomTypes()
     * - A type index from metadata
     * @param payload The data to encode or decode:
     * - For encoding: Pass the raw value
     * - For decoding: Pass the hex string or Uint8Array
     * @returns A Codec instance that provides methods like:
     * - toHex(): Get hex representation
     * - toHuman(): Get human readable format
     * - toJSON(): Get JSON format
     * - toU8a(): Get Uint8Array bytes
     *
     * @example
     * ```typescript
     * // Encoding a string
     * const createType = new CreateType();
     * const encoded = createType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     *
     * // Decoding hex data
     * const decoded = createType.create('String', '0x48656c6c6f2c20576f726c6421');
     * console.log(decoded.toHuman()); // "Hello, World!"
     *
     * // Using custom types
     * createType.registerCustomTypes({
     *   User: {
     *     name: 'String',
     *     age: 'u8'
     *   }
     * });
     * const user = createType.create('User', { name: 'Alice', age: 25 });
     * ```
     */
    create(typeOrTypeIndex, payload) {
        let [type, index] = typeof typeOrTypeIndex === 'string' ? [typeOrTypeIndex, undefined] : [undefined, typeOrTypeIndex];
        if (payload === undefined) {
            payload = '0x';
        }
        else if (json.isJSON(payload)) {
            payload = json.toJSON(payload);
        }
        if (type === undefined) {
            type = 'Bytes';
        }
        if (this.metadata) {
            index = index || this.metadata.getTypeIndexByName(type);
            return this.metadata.createType(index, payload);
        }
        return this.registry.createType(type, payload);
    }
    /**
     * Static method to create a Codec instance for encoding/decoding data.
     *
     * @param type The type name to encode/decode the payload (e.g. 'String', 'u32', custom type)
     * @param payload The data to encode or hex string to decode
     * @param hexRegistry Optional hex-encoded type registry for custom types
     * @returns A Codec instance with methods like toHex(), toHuman(), toJSON(), toU8a()
     *
     * @example
     * ```typescript
     * // Encode a string
     * const encoded = CreateType.create('String', 'Hello, World');
     * console.log(encoded.toHex()); // 0x48656c6c6f2c20576f726c6421
     *
     * // Decode hex data
     * const decoded = CreateType.create('String', '0x48656c6c6f2c20576f726c6421');
     * console.log(decoded.toJSON()); // "Hello, World"
     *
     * // Using custom types with registry
     * const registry = '0x...'; // Hex registry containing custom type definitions
     * const result = CreateType.create('MyCustomType', data, registry);
     * ```
     */
    static create(type, payload, hexRegistry) {
        const createType = new CreateType(hexRegistry);
        return createType.create(type, payload);
    }
}

exports.CreateType = CreateType;
