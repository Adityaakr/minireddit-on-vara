/**
 * The Message from GearEthBridge.MessageQueued event
 */
class GearEthBridgeMessage {
    /** Unique identifier for the message */
    nonce;
    /** Source address where the message originated */
    source;
    /** Destination address where the message should be delivered */
    destination;
    /** The actual message data as hex-encoded bytes */
    payload;
    constructor(msg) {
        this.nonce = msg.nonce.toBigInt();
        this.source = msg.source.toHex();
        this.destination = msg.destination.toHex();
        this.payload = msg.payload.toHex();
    }
}
const SECTION = 'gearEthBridge';
/**
 * Event monitoring and filtering utilities for GearEthBridge pallet.
 */
class GearEthBridgeEvents {
    _api;
    constructor(_api) {
        this._api = _api;
    }
    /**
     * Subscribe to a specific bridge event type.
     *
     * @param name - The name of the event to subscribe to
     * @param callback - Function called when the event occurs
     * @returns Unsubscribe function to stop listening for events
     */
    on(name, callback) {
        const unsub = this._api.query.system.events(async (events) => {
            const filtered = events.filter(({ event: { section, method } }) => section === SECTION && method === name);
            if (filtered.length === 0)
                return;
            for (const e of filtered) {
                if (['BridgeCleared', 'BridgeInitialized', 'BridgePaused', 'BridgeUnpaused'].includes(name)) {
                    await callback();
                    return;
                }
                if (['AuthoritySetHashChanged', 'QueueMerkleRootChanged'].includes(name)) {
                    await callback(e.event.data.toHex());
                }
            }
            if (name === 'MessageQueued') {
                const { message, hash } = filtered[0].event.data;
                await callback(new GearEthBridgeMessage(message), hash.toHex());
            }
        });
        return async () => {
            (await unsub)();
        };
    }
    /**
     * Find a bridge message by its nonce within a specified block range.
     *
     * This method subscribes to blocks starting from the specified block and searches
     * for a message with the given nonce. It will continue searching until either:
     * - The message is found
     * - The toBlock limit is reached (if specified)
     *
     * @param args - Search parameters including nonce and block range
     * @returns The found message or null if not found within the range
     */
    async findGearEthBridgeMessageByNonce({ nonce, fromBlock, toBlock, }) {
        let resolver = null;
        const resultPromise = new Promise((resolve) => {
            resolver = resolve;
        });
        let unsub;
        try {
            unsub = await this._api.blocks.subscribeToHeadsFrom(fromBlock, async (header) => {
                if (toBlock && header.number.toNumber() >= toBlock) {
                    resolver(null);
                }
                const events = await this._api.at(header.hash).then((apiAt) => apiAt.query.system.events());
                const filtered = events.filter(({ event: { section, method } }) => section === SECTION && method === 'MessageQueued');
                if (filtered.length === 0)
                    return;
                for (const { event } of filtered) {
                    const { message } = event.data;
                    if (message.nonce.toBigInt() === nonce) {
                        return resolver(new GearEthBridgeMessage(message));
                    }
                }
            });
            return resultPromise;
        }
        finally {
            unsub?.();
        }
    }
}

export { GearEthBridgeEvents };
