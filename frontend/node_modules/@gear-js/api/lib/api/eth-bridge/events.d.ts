import { Struct, U256, u8, Vec } from '@polkadot/types';
import { H256 } from '@polkadot/types/interfaces';
import { HexString } from '../../types/index.js';
import { GearApi } from '../../GearApi';
/**
 * The Message from GearEthBridge.MessageQueued event
 */
declare class GearEthBridgeMessage {
    /** Unique identifier for the message */
    readonly nonce: bigint;
    /** Source address where the message originated */
    readonly source: `0x${string}`;
    /** Destination address where the message should be delivered */
    readonly destination: `0x${string}`;
    /** The actual message data as hex-encoded bytes */
    readonly payload: `0x${string}`;
    constructor(msg: GearEthBridgeMessageQueuedMessageCodec);
}
interface GearEthBridgeMessageQueuedMessageCodec extends Struct {
    readonly nonce: U256;
    readonly source: H256;
    readonly destination: H256;
    readonly payload: Vec<u8>;
}
/**
 * Type mapping for all Gear-Ethereum bridge events and their parameters.
 *
 * Each event type maps to an array of its parameter types for type safety.
 */
interface GearEthBridgeEventNames {
    /** Emitted when the authority set hash changes */
    AuthoritySetHashChanged: [HexString];
    /** Emitted when the bridge message queue is cleared */
    BridgeCleared: [];
    /** Emitted when the bridge is first initialized */
    BridgeInitialized: [];
    /** Emitted when the bridge is paused */
    BridgePaused: [];
    /** Emitted when the bridge is unpaused */
    BridgeUnpaused: [];
    /** Emitted when a new message is queued for processing */
    MessageQueued: [message: GearEthBridgeMessage, hash: HexString];
    /** Emitted when the queue merkle root changes */
    QueueMerkleRootChanged: [HexString];
}
/**
 * Arguments for finding a bridge message by its nonce.
 */
interface FindByNonceArgs {
    /** The nonce of the message to search for */
    nonce: bigint;
    /** The block number to start searching from */
    fromBlock: number;
    /** Optional block number to stop searching at */
    toBlock?: number;
}
/**
 * Event monitoring and filtering utilities for GearEthBridge pallet.
 */
export declare class GearEthBridgeEvents {
    private _api;
    constructor(_api: GearApi);
    /**
     * Subscribe to a specific bridge event type.
     *
     * @param name - The name of the event to subscribe to
     * @param callback - Function called when the event occurs
     * @returns Unsubscribe function to stop listening for events
     */
    on<K extends keyof GearEthBridgeEventNames>(name: K, callback: (...args: unknown[]) => void | Promise<void>): () => Promise<void>;
    /**
     * Find a bridge message by its nonce within a specified block range.
     *
     * This method subscribes to blocks starting from the specified block and searches
     * for a message with the given nonce. It will continue searching until either:
     * - The message is found
     * - The toBlock limit is reached (if specified)
     *
     * @param args - Search parameters including nonce and block range
     * @returns The found message or null if not found within the range
     */
    findGearEthBridgeMessageByNonce({ nonce, fromBlock, toBlock, }: FindByNonceArgs): Promise<GearEthBridgeMessage | null>;
}
export {};
